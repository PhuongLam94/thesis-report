\chapter{Kiểm tra kiểu - Type checking}
\label{chap:typechecking}
Giải pháp Kiểm tra kiểm gồm có các bước sau đây:
\begin{itemize}
\item Rút trích thông tin từ phần chú thích trong đoạn mã chương trình đầu vào để biết được các biến byte - biến bit nào thuộc cùng một bộ.
\item Thực hiện phân tích dữ liệu để biết được giá trị của thanh ghi ACC tại một thời điểm của chương trình.
\item Tại các câu lệnh sử dụng biến bit, tiến hành các bước kiểm tra nguyên tắc sử dụng bộ biến.
\end{itemize}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{image/soDoTypeChecking}
	\caption{Sơ đồ các bước thực hiện giải pháp Kiểm tra kiểu}
	\label{fig:sodotypechecking}
\end{figure}

Các phần tiếp theo của chương sẽ trình bày lần lượt các bước này.

\begin{comment}
\section{Chỉnh sửa để Boomerang chấp nhận việc sử dụng biến không phải thanh ghi}
\subsection{Cơ chế lưu trữ tên thanh ghi hiện nay của Boomerang}
Khi chuyển đổi từ mã assembly sang mã trung gian, Boomerang sẽ dùng một class con của Expr để biểu diễn thanh ghi. Cụ thể là class Location, và gọi phương thức static của class Location là Location::regOf(int num). Ta sẽ truyền vào phương thức này một con số đại diện cho thanh ghi đó. Cặp số - tên thanh ghi này được lưu vào một từ điển, để sau này khi thực hiện phân tích xong thì sẽ chuyển lại từ thanh ghi thành biến cục bộ.

Trong phần giải mã từ mã assembly sang mã trung gian, có một hàm để map giữa tên thanh ghi và con số đại diện cho nó, đó là hàm map\_sfr(string name).
\begin{lstlisting}[caption={Một số phần mã trong hàm map\_sfr},label={list:listmapsfr}]
if (name == "R0") return 0;
else if (name == "R1") return 1;
else if (name == "R2") return 2;
...
else return -1;

\end{lstlisting}

Sau khi trải qua các quá trình phân tích và đến giai đoạn in ra mã đầu ra, trình dịch ngược sẽ gọi hàm getRegName trong class FrontEnd để trả lại tên ban đầu của thanh ghi. Trong hàm getRegName sẽ lấy từ điển tên thanh ghi - số đại diện được quy định sẵn của mỗi phần giải mã cho các kiến trúc máy khác nhau, tìm tên thanh ghi tương ứng với con số đó và trả về.
\begin{lstlisting}[caption={Phần mã trong hàm getRegName},label={list:listgetregname}]
std::map<std::string, int, std::less<std::string> >::iterator it;
for (it = decoder->getRTLDict().RegMap.begin();	 it != decoder->getRTLDict().RegMap.end(); it++)
if ((*it).second == idx) 
return (*it).first.c_str();
return NULL;
\end{lstlisting}


Như vậy, có thể thấy với các tên biến không được quy định trước, hàm map\_sfr sẽ trả về giá trị -1, và vì giá trị -1 sẽ không có trong từ điển của phần giải mã, nên hàm getRegName sẽ trả về NULL, dẫn đến trình dịch ngược sẽ bị lỗi runtime và dừng ngay lập tức.\\

%lấy mã Boomerang ban đầu về, hiện kết quả khi sử dụng biến đầu vào

Vì số lượng tên biến là rất nhiều, nên ta không thể sử dụng phương pháp thêm mới các tên biến vào từ điển được quy định sẵn được, mà phải có cách để trình dịch ngược linh động hơn, chấp nhận bất kỳ các tên nào được sử dụng trong mã assembly. Giải pháp đưa ra là ngoài việc sử dụng từ điển thanh ghi được quy định sẵn, ta sẽ lập thêm một bảng tên biến, thành phần bao gồm các cặp tên biến - số đại diện. Trong giai đoạn giải mã, khi hàm map\_sfr được gọi, nếu tên truyền vào nằm trong các thanh ghi đã quy định sẵn, thay vì trả về giá trị -1 thì ta sẽ tạo ra một giá trị random và đưa chúng vào bảng tên biến ở trên. Ngoài ra, còn có một đoạn mã kiểm tra biến được sử dụng đã được khai báo bằng câu lệnh \#DEFINE chưa (ngoại trừ một số biến đặc biệt được tự sinh). \\
\begin{lstlisting}[caption={Phần mã mới được bổ sung trong hàm map\_sfr},label={list:listmapsfrnew},language=c++]
bool isDefined = false;
map<char*, AssemblyArgument*>::iterator it;
for (it = replacement.begin(); it!=replacement.end(); it++){
if(strcmp((*it).first, name.c_str()) == 0 ){
isDefined = true;
break;
}
}
if (isDefined || name.find("specbits") != string::npos ){
if (symbolTable->find(name) == symbolTable->end()){
bool existed = false;
int num;
do{
num = std::rand()%200+31;
map<string, int>::iterator it;
for (it = symbolTable->begin(); it!=symbolTable->end(); it++){
bool cond1 = (*it).second == num;
bool cond2 = (byteVar != -1 && byteVar>=num);
bool cond3 = (bit != -1 && bit>=num);
if (cond1 || cond2 || cond3){
existed = true;
continue;
} else {
existed = false;
}
}
} while (existed); 
(*symbolTable)[name] = num;
if (name.find("specbits") != string::npos){
std::cout<<"Name: "<<name<<", "<<num<<endl;
}
return num;
} else {
return symbolTable->find(name)->second;
}
}
else {
std::cout<<"ERROR: "<<name<<" HAS NOT BEEN DEFINED YET"<<endl;
exit(1);
}
\end{lstlisting}
Tương ứng với sự thay đổi ở hàm map\_sfr,  ở hàm getRegName, ngoài việc dò trong từ điển quy định trước, ta sẽ thêm một đoạn mã để dò trong bảng tên biến. 
\begin{lstlisting}[caption={Phần mã mới được bổ sung trong hàm getRegName},label={list:listgetregnamenew},language=c++]
std::map<string,int>::iterator symIt;
for (symIt = decoder->getSymbolTable().begin(); symIt != decoder->getSymbolTable().end(); symIt++){
	if ((*symIt).second == idx){
		return (*symIt).first.c_str();
	}
}
\end{lstlisting}
Như vậy, vấn đề giữ nguyên tên biến được giải quyết mà không ảnh hưởng nhiều tới trình dịch ngược.
%đoạn mã đầu vào assembly và mã đầu ra giữ nguyên được tên biến
\end{comment}
\section{Rút trích thông tin từ phần chú thích}
Khi lập trình bằng ngôn ngữ assembly và có sử dụng tên biến, các lập trình viên thường có phần chú thích bên cạnh để biết được các biến này dùng cho mục đích gì. Đối với các tên biến bit, người lập trình còn phải chỉ rõ ra họ sẽ dùng biến bit này với biến byte nào. Như vậy, nếu đọc các phần chú thích này, những người lập trình khác sẽ biết được các biến byte - biến bit nào là cùng một bộ với nhau và sử dụng đúng theo nguyên tắc. Tuy nhiên, để làm cho trình dịch ngược cũng đọc được thông tin này, cần phải có một quy định chung về việc chú thích cho các tên biến. Mẫu khai báo này được trình bày ở đoạn mã \ref{list:listdeclarevar}. Vì các thay đổi nằm ở phần chú thích, nên sẽ không ảnh hưởng tới nội dung chính của chương trình đầu vào.

\begin{lstlisting}[caption={Mẫu khai báo bộ biến},label={list:listdeclarevar}]
;BEGIN DEFINE
;BYTE VAR
[byte var declare]
;BIT VAR
[eight bit var declares]
;END DEFINE
\end{lstlisting}

Như vậy, cần chỉnh lại phần parser của trình dịch ngược để chấp nhận cấu trúc mới này. Ngoài ra, trong trình dịch ngược, cần có một cấu trúc mới để lưu trữ thông tin của các bộ biến byte và biến bit này. Trong đoạn mã \ref{list:listuniondefine}, có một trường byteVar để lưu tên biến byte, và một sơ đồ lưu thứ tự của biến bit và tên biến bit tương ứng. Hiện tại, cấu trúc này đã đủ cho giải pháp Kiểm tra kiểu. Tuy nhiên, nó sẽ được mở rộng ở giải pháp sau. 
\begin{lstlisting}[caption={Cấu trúc dữ liệu để lưu trữ một bộ biến},label={list:listuniondefine},language=c++]
class UnionDefine{
	public:
	char* byteVar;
	map<int, char*>* bitVar;
	}
};
\end{lstlisting}
Như vậy, ta cần phải điều chỉnh lại phần parser của trình dịch ngược, sao cho nó vừa chấp nhận mẫu khai báo biến trên, vừa đưa từng bộ biến được khai báo vào trong một thực thể của class \textit{UnionDefine}. Kết quả là, sau khi kết thúc phần parser, ta sẽ thu được một danh sách các \textit{UnionDefine} tương ứng với các khai báo các bộ biến. Đoạn mã \ref{list:listparser} là phần parser viết dựa trên thư viện Bison++ để thực hiện chức năng trên.\\
\begin{lstlisting}[caption={Đoạn mã parser cho phần khai báo bộ biến},label={list:listparser}]
definebit: BEGINDEFINE END_LINE DEFINEBYTE END_LINE 
define DEFINEBITS END_LINE defineeachbit defineeachbit
defineeachbit defineeachbit defineeachbit defineeachbit 
defineeachbit defineeachbit ENDDEFINE END_LINE
{
	UnionDefine* ut = new UnionDefine();
	$5 -> expList -> pop_back();
	ut->byteVar = $5 -> expList -> back() -> argList.back()->value.c;
	ut->bitVar = bitVar;
	unionDefine1 -> push_back(ut);
	bitVar = new map<char*, int>();
}
;
defineeachbit: DEFINE ID bit END_LINE {
	std::string temp($3->value.c);
	char c =  temp.at(temp.size()-1);
	int num = c - '0';
	(*bitVar)[$2] = num;
}
;
\end{lstlisting}
Như vậy, sau giai đoạn parser, ta đã thu được bộ biến theo khai báo của người dùng. Tuy nhiên, nguyên tắc sử dụng bộ biến này là không bắt buộc trong quá trình lập trình 8051, và các assembler cũng không hề kiểm tra việc người dùng có tuân thủ nguyên tắc này không. Vì vậy, trước khi chuyển hoá các bộ biến này sang cấu trúc union ở mã đầu ra, ta cần phải kiểm tra đoạn mã của người dùng sử dụng các bộ biến như thế nào.

\section{Kiểm tra nguyên tắc sử dụng bộ biến}
\subsection{Xác định giá trị kiểu của thanh ghi \textit{ACC} tại mỗi điểm của chương trình}
Để kiểm tra được nguyên tắc sử dụng bộ biến, trước hết, ta phải biết được tại mỗi thời điểm của chương trình, thanh ghi \textit{ACC} đang mang giá trị gì. Có hai phương pháp phân tích được áp dụng trong giải pháp này, đó là Reaching definitions kết hợp phần mở rộng và Type propagation.
\subsubsection{Phân tích Reaching definitions kết hợp phần mở rộng}
Mục đích của phân tích Reaching definitions là biết được ở một thời điểm của chương trình, các câu lệnh khai báo nào đang còn hiệu lực, hay nói cách khác là gía trị của các biến đang được khai báo bởi những câu lệnh nào. Phần mở rộng của Reaching definition sẽ giúp xử lý thêm một số trường hợp, khi thanh ghi được truyền giá trị thông qua một thanh ghi trung gian khác.
\begin{figure}
	\centering
	\includegraphics[scale=0.75]{image/reachingDefExam}
	\caption{Một đoạn chương trình mẫu}
	\label{fig:reachingdefexam}
\end{figure}
Ví dụ như ở đoạn chương trình \ref{fig:reachingdefexam}, ta cần biết được giá trị của biến \textit{a} ở câu lệnh số 2 được khai báo ở câu lệnh nào. Đối với con người thì rất dễ dàng biết được là biến \textit{a} được sử dụng có thể khai báo ở câu lệnh số 1 hoặc câu lệnh số 5. Tuy nhiên, cần có một phương pháp phân tích để cho máy tính cũng biết được điều đó, và đó chính là phương pháp Reaching definitions. Như vậy, khi áp dụng vào trình dịch ngược, ta sẽ biết được tại thời điểm sử dụng biến bit, giá trị của thanh ghi \textit{ACC} đang được định nghĩa ở câu lệnh nào. Từ đó tiến hành các bước kiểm tra tiếp theo. \\

Để thực hiện Reaching definitions, ta phải làm quen với các định nghĩa sau:
\begin{itemize}
	\item Nếu một biến được khai báo ở câu lệnh \textit{def1}, sau đó được khai báo lại ở câu lệnh \textit{def2} sau đó, thì ta nói là câu lệnh \textit{def1} đã \textbf{bị giết (killed)} bởi câu lệnh \textit{def2}.
	\item Nếu có một đường thực thi chương trình đi từ câu lệnh khai báo \textit{def1} đến một điểm \textit{p} của chương trình, mà trên đó \textit{def1} không bị giết bởi bất kỳ câu lệnh nào, thì ta nói là \textit{def1} đã \textbf{đến được (reach))} điểm \textit{p}. Khái niệm một câu lệnh đến được một khối cơ bản cũng tương tự như vậy.
\end{itemize}

Ngoài ra, ta phải quy định một số khái niệm mới cho một khối cơ bản B:
\begin{itemize}
	\item \textit{REACHin(B)}: Tập hợp các câu lệnh khai báo đến được đầu vào (entry) của B.
	\item \textit{REACHout(B)}: Tập hợp các câu lệnh khai báo đến được ngõ ra (exit) của B.
	\item \textit{GEN(B)}: Tập hợp các câu lệnh khai báo xuất hiện trong B và có thể đến được ngõ ra (exit) của B, nghĩa là biến được khai báo trong câu lệnh đó không được khai báo lại ở các câu lệnh đằng sau nó.
	\item \textit{KILL(B)}: Tập hợp các câu lệnh khai báo mà biến được khai báo đã được khai báo lại trong B.
\end{itemize}

Như vậy, mục tiêu của phân tích Reaching definitions ở cấp độ khối cơ bản là tìm ra được tập hợp \textit{REACHin} và \textit{REACHout} của từng khối. Công thức được áp dụng là;
\begin{equation} \label{eq:reachout}
	REACHout(B) = GEN(B) \cup (REACHin(B)-KILL(B))
\end{equation}	
\begin{equation} \label{eq:reachin}
REACHin(B) = \cup_{j \in Pred(B)} REACHout(j)
\end{equation}	

Từ hai công thức \ref{eq:reachout} và \ref{eq:reachin}, ta thấy ở phân tích này, tập hợp các giá trị ra (\textit{REACHin}) được quyết định bởi các giá trị vào (\textit{REACHout}), ngược lại với phân tích liveness (tìm tập hợp biến đang sống tại một thời điểm của chương trình). Như vậy, luồng đi của phân tích là cùng chiều với luồng đi của chương trình. Tương tự một số phương pháp phân tích dữ liệu khác, ta sẽ lần lượt tính toán các tập hợp vào và tập hợp ra của từng khối cơ bản cho đến khi không còn thay đổi nào được ghi nhận. Xem sơ đồ khối hình \ref{fig:reachingdefalgo}.

\begin{figure}
	\centering
	\includegraphics[scale=0.75]{image/reachingDefAlgo}
	\caption{Giải thuật tính Reaching definitions cho khối cơ bản}
	\label{fig:reachingdefalgo}
\end{figure}

Tuy nhiên, trong trường hợp của bài toán cần giải quyết, ta cần phải biết tập hợp ra vào của từng câu lệnh một, chứ không chỉ của toàn bộ khối cơ bản, vì vậy, khi ứng dụng vào Boomerang, giải thuật sẽ được điều chỉnh lại để tìm tập \textit{REACHin} và \textit{REACHout} của từng câu lệnh. Việc điều chỉnh này là khá nhỏ, và các bước vẫn sẽ giữ nguyên, không thay đổi nhiều.\\

Khuyết điểm lớn nhất của phân tích Reaching definitions chỉ cho biết được câu lệnh khai báo có hiệu lực của một biến tại một thời điểm chương trình, chứ không cho biết được giá trị thực sự của biến đó. Cụ thể, với thanh ghi \textit{ACC}, nếu vế phải của câu lệnh khai báo này chỉ đơn giản là trỏ đến một vùng nhớ có địa chỉ được quy định bởi một biến byte thì biến byte đó sẽ được ghi nhận là đại diện cho vùng nhớ hiện thời \textit{ACC} đang lưu trữ. Nhưng ngoài ra, biểu thức quy định địa chỉ vùng nhớ được gán cho \textit{ACC} có thể là các trường hợp sau đây:
\begin{itemize}
	\item Một hằng số.
		\item Một thanh ghi, giá trị của thanh ghi có thể được khai báo ở các câu lệnh trước đó.
	\item Một biểu thức có hai vế, các vế của biểu thức có thể là một biến, một thanh ghi hoặc một hằng số.

\end{itemize}

\begin{lstlisting}[caption={Một số câu lệnh gán mà phương pháp Suy luận kiểu sử dụng Reaching definitions không xử lý được},label={list:listhardcase}]
MOV A, 38H #1
MOV A, @DPTR #2
MOV A, OPTION+1 #2
\end{lstlisting}
Các trường hợp phức tạp nêu trên được trình bày trong đoạn mã \ref{list:listhardcase}. 
Phương pháp Reaching definitions sẽ không thể xử lý được khi gặp các câu lệnh gán này. Ở câu lệnh số 1, phân tích có thể lấy được giá trị \textbf{38H}, nhưng không thể xác định được biến byte nào đã được khai báo giá trị \textbf{38H}. Ở câu lệnh số 2, Reaching definitions không thể biết được giá trị của thanh ghi \textit{DPTR} là bao nhiêu. Ở câu lệnh số 3, việc xử lý lại càng phức tạp hơn, vì nếu chỉ đơn giản lấy vế phải của khai báo ra, không thể nào biết được giá trị thực sự của nó là bao nhiêu.
Ngoài ra, với trường hợp trong tập hợp \textit{REACHin} của câu lệnh có nhiều câu lệnh khai báo cho thanh ghi \textit{ACC}, phương pháp này sẽ không thể kiểm tra được vế phải của tất cả các câu lệnh khai báo đó có cùng một giá trị hay không mà chỉ đơn giản xử lý là câu lệnh đã vi phạm nguyên tắc sử dụng bộ biến. Ví dụ như đoạn mã \ref{list:ifcond}, tại thời điểm câu lệnh sử dụng biến bit \textit{TESTSUPS}, có hai câu lệnh khai báo biến \textit{a} (là biến đại diện cho thanh ghi \textit{ACC} tại ngôn ngữ trung gian). Đối với phương pháp Reaching definitions, nó sẽ xem như có hai giá trị mà biến \textit{a} có thể mang, và sẽ báo lỗi vì vi phạm nguyên tắc sử dụng bộ biến. Tuy nhiên, nếu xét kỹ hơn, thì sẽ thấy là cả hai giá trị đó đều là biến \textit{OPTIONS}, và thực chất tại thời điểm này \textit{a} chỉ mang một giá trị, cho dù luồng đi của chương trình có như thế nào. Như vậy, phương pháp Reaching definitions sẽ bỏ qua những trường hợp như thế này và báo lỗi, dẫn đến việc độ chính xác sẽ không được cao.
\begin{lstlisting}[caption={Đoạn mã có nhiều câu lệnh khai báo cho ACC đến được một điểm của chương trình nhưng tất cả đều cùng giá trị},label={list:ifcond}]
if (...){
	a = *(OPTIONS);
	...
} else {
	a = *(OPTIONS);
	...
}
TESTSUPS = 1;
\end{lstlisting}

Để khắc phục phần nào khuyết điểm của Reaching definitions, một phần mở rộng được thêm vào để giải quyết một trong những trường hợp mà phương pháp này không thể giải quyết được. Đó là trường hợp sử dụng một biến trung gian và sử dụng hằng (câu lệnh số 1 và số 2 ở đoạn mã \ref{list:listhardcase}). Các trường hợp này được giải quyết nhờ vào việc lưu trữ các khai báo \textit{\#DEFINE} ở đoạn mã đầu vào, cũng như trong quá trình phân tích, tất cả các câu lệnh khai báo của tất cả các biến đến được một điểm trong chương trình đều được lưu giữ chứ không chỉ riêng của thanh ghi \textit{ACC}. Cụ thể các bước của phần mở rộng được trình bày ở hình \ref{fig:reachdefextendalgo}.
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{image/reachdefextendalgo}
	\caption{Giải thuật cho hàm findRegValue - phần mở rộng của phân tích Reaching definitions}
	\label{fig:reachdefextendalgo}
\end{figure}

Theo giải thuật nêu trên, để tìm được giá trị của thanh ghi \textit{ACC} tại một thời điểm của chương trình, cần truyền vào hàm \textit{findRegValue} tên thanh ghi ("ACC"), giá trị true để hàm biết đang tìm kiếm giá trị cho thanh ghi \textit{ACC}, tập REACHin tại thời điểm đó của chương trình và danh sách các cặp tên biến - giá trị biến được khai báo ở phần đầu của mã đầu vào. Qua các bước của giải thuật, hàm sẽ trả về giá trị là biến byte quy định vùng nhớ được load dữ liệu vào \textit{ACC} nếu tìm được biến này, còn nếu trả về giá trị \textbf{NULL}, nghĩa là giải thuật đã gặp phải trường hợp không xử lý được, đó là trường hợp biểu thức vế phải gồm hai toán hạng (câu lệnh số 3 của đoạn mã \ref{list:listhardcase}).

Tuy đã xử lý được hầu hết các trường hợp của phép gán cho \textit{ACC}, nhưng việc có thêm một phần mở rộng này sẽ làm cho tốc độ xử lý trình dịch ngược giảm đi. Cộng thêm việc bản thân giải thuật Reaching definitions đã có độ phức tạp cao, tổng thời gian xử lý cho bước này của trình dịch ngược là khá lớn. Vì vậy, một phương pháp phân tích khác đã được thực hiện để tìm ra giá trị của thanh ghi \textit{ACC} với độ phức tạp thấp hơn.

\subsubsection{Phân tích Type propagation}
Phân tích Type propagation có mục đích sẽ tìm ra được kiểu của một thanh ghi bằng cách lan truyền kiểu của những thanh ghi khác. Áp dụng vào trường hợp cụ thể của luận văn, các tên biến byte có thể được xem là một kiểu, vì khi chuyển đổi bộ biến thành một kiểu union ở ngôn ngữ cấp cao, tên biến byte này sẽ được dùng để đặt tên cho kiểu union đó. Như vậy, tác dụng của phân tích Type propagation này là tìm ra được thanh ghi ACC đang mang kiểu union nào tại một thời điểm của chương trình. Các bước của giải thuật phân tích Type propagation được trình bày ở hình \ref{fig:typepropagationalgo}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{image/typePropagationAlgo}
	\caption{Giải thuật của phân tích Type propagation}
	\label{fig:typepropagationalgo}
\end{figure}

Trong giải thuật đã trình bày ở trên, không xét đến trường hợp một biến được khai báo lại nhiều lần và tại mỗi thời điểm sẽ có giá trị khác nhau là do tận dụng được mã trung gian SSA. Hầu hết các trình dịch ngược đều sử dụng mã SSA tại một giai đoạn nào đó trong quá trình phân tích dữ liệu vì các lợi ích của loại mã này (chi tiết về mã SSA được trình bày trong phần \ref{ssa}). Với mã SSA, mỗi biến chỉ được khai báo một lần duy nhất trong chương trình, nên không bị ảnh hưởng bởi trường hợp khai báo lại biến.\\

Như vậy, phương pháp Type propagation này sẽ làm giảm đáng kể thời gian xử lý của chương trình so với phương pháp Reaching definitions. Khi có một thay đổi nào đó, chương trình phân tích chỉ cần tính toán lại các câu lệnh khai báo chịu ảnh hưởng của sự thay đổi đó, chứ không cần phải tính toán lại hết tất cả các câu lệnh như giải thuật của Reaching definitions. Phương pháp này cũng không cần một phần mở rộng mà ngay trong quá trình lan truyền, nó đã tính toán được các trường hợp biểu thức vế phải của khai báo là một thanh ghi hoặc một hằng số. Khuyết điểm của Type propagation là vẫn chưa xử lý được trường hợp biểu thức vế phải có hai toán hạng. Để giải quyết được vấn đề này, cần có một phân tích khác mạnh hơn và phân tích đó sẽ được giới thiệu ở chương tiếp theo.
\subsection{Kiểm tra tính hợp lệ về kiểu của tác vụ với bit}

\label{sec:laststep}

Sau khi đã tìm được thông tin về kiểu của thanh ghi ACC tại mỗi điểm của chương trình, bước tiếp theo của giải pháp Kiểm tra kiểu là kiểm tra tính hợp lệ khi sử dụng các biến bit. Như đã trình bày ở phần \ref{sec:problem}, việc sử dụng các biến byte - biến bit trong mã chương trình 8051 cần tuân thủ các quy định sau:
\begin{itemize}
	\item Chỉ khi thanh ghi \textit{ACC} đang mang giá trị của vùng nhớ có địa chỉ quy định bởi biến byte, thì các biến bit cùng bộ mới được sử dụng.
	\item Mỗi biến bit chỉ thuộc một bộ duy nhất. 
	\item Tại mỗi vị trí bit của một bộ biến chỉ có một biến bit duy nhất tồn tại. 
\end{itemize}
Như vậy, ở phần này, chương trình sẽ chạy vòng lặp kiểm tra lần lượt từng câu lệnh sử dụng bit để xem xét việc sử dụng này có vi phạm quy định nào trong những quy định trên hay không. Các bước kiểm tra này được trình bày ở hình \ref{fig:checkunionsteps}.
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{image/checkUnionSteps}
	\caption{Quá trình kiểm tra một câu lệnh sử dụng bit}
	\label{fig:checkunionsteps}
\end{figure}
Nếu có một câu lệnh sử dụng bit nào đó vi phạm nguyên tắc trên, chương trình kiểm tra vẫn tiếp tục chạy để kiểm tra những câu lệnh sau đó. Điều này giúp người lập trình biết được tất cả các lỗi trong chương trình đầu vào của mình để có sự chỉnh sửa phù hợp. Tuy nhiên, khi có vi phạm xảy ra, trình dịch ngược sẽ không sinh được mã đầu ra, vì không có cách thể hiện union phù hợp.

%đoạn mã và output của trình dịch ngược khi vi phạm nguyên tắc sử dụng
\begin{comment}
Kết thúc quá trình kiểm tra lỗi, nếu không có vi phạm nào xảy ra, trình dịch ngược sẽ tiến hành sinh ra thêm một số khai báo cho bộ biến, cũng như thực hiện các thay thế cần thiết. Các bộ biến được khai báo được lưu bằng cấu trúc UnionDefine, và ta cần thể hiện các bộ biến đó bằng một cấu trúc dữ liệu ở ngôn ngữ cấp cao của mã đầu ra. Như đã phân tích từ trước ở chương \ref{sec:gioithieu}, cấu trúc dữ liệu đó là union. Hình \ref{fig:uniondefinemapping} thể hiện việc chuyển đổi của class UnionDefine sang cấu trúc union.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{image/unionDefineMapping}
	\caption{Hình minh hoạ việc chuyển đổi từ class UnionDefine sang cấu trúc union ở mã đầu ra}
	\label{fig:uniondefinemapping}
\end{figure}

Sau khi sinh ra các union như trên, ta cần tiến hành thực hiện các thay thế sau:
\begin{itemize}
	\item Thay thế các biểu thức thể hiện biến bit dưới dạng thanh ghi độc lập thành một biểu thức truy xuất đến một thành phần của union tương ứng với bộ biến mà biến bit đó thuộc về. Vì ở giai đoạn giải mã, ta không thực hiện kiểm tra biến nào là biến bit, biến nào là biến byte, nên ta sẽ xem tất cả các biến như những thanh ghi độc lập nhau. Sau khi đã trải qua các quá trình phân tích và sinh ra các union, ta cần thay thế để thể hiện rõ mối liên hệ giữa biến bit và biến byte.
	
	\item Thay thế các biểu thức truy xuất trực tiếp bit của thanh ghi ACC thành biểu thức truy xuất đến một thành phần của union tương ứng với bộ biến chứa biến byte mà thanh ghi ACC đang mang giá trị trỏ đến. Vì một số lý do, có đôi khi người lập trình viên không sử dụng biến bit mà sử dụng một truy xuất trực tiếp đến bit trong thanh ghi ACC, ví dụ như: ACC.1. Với trường hợp này, vì ta đã có trong tay bộ biến và giá trị của biến byte thanh ghi ACC đang được trỏ đến, ta sẽ thay thế để đoạn mã đầu ra thống nhất hơn, và có thể tiến hành bước thay thế thanh ghi ACC được trình bày bên dưới. Lưu ý: trong giai đoạn giải mã, ghi gặp biểu thức ACC.x, trình giải mã sẽ chuyển chúng về một thanh ghi đặc biệt có tên là specbitsx, với x là số thứ tự của bit muốn truy xuất (xem ví dụ đoạn mã \ref{list:listbeforereplacebit}).
	\begin{lstlisting}[caption={Mã đầu ra trước khi thực hiện bước thay thế biến bit},label={list:listbeforereplacebit}, language = c]
	TESTSUPS = 1;
	if (specbits5 == 1){
		 ...
	}
	\end{lstlisting}
	
	\begin{lstlisting}[caption={Mã đầu ra sau khi thực hiện bước thay thế biến bit},label={list:listafterreplacebit}, language = c]
	OPTIONS.bits.TESTSUPS = 1;
	if (OPTIONS.bits.bit1 == 1){
		...
	}
	\end{lstlisting}
\item Thay thế các vị trí sử dụng thanh ghi ACC bằng biến byte tương ứng. Khi lập trình ở dạng mã assembly, lập trình viên không được phép xử lý các vùng nhớ trực tiếp mà phải thông qua thanh ghi, tuy nhiên, khi đã chuyển đổi về dạng ngôn ngữ cấp cao, ta có thể sử dụng trực tiếp tên biến trong các câu lệnh mà không cần trung gian qua thanh ghi nữa. Điều này giúp mã đầu ra dễ hiểu và trong sáng hơn.

\begin{lstlisting}[caption={Mã đầu ra trước khi thực hiện bước thay thế thanh ghi ACC},label={list:listbeforereplace}]
a = *OPTIONS;
OPTIONS.bits.TESTSUPS1 = 1;
return a;
\end{lstlisting}
\begin{lstlisting}[caption={Mã đầu ra sau khi thực hiện bước thay thế thanh ghi ACC},label={list:listafterreplace}]
OPTIONS.bits.TESTUPS1 = 1;
return OPTIONS.byte;
\end{lstlisting}
\end{itemize}

\end{comment}
Như vậy, với giải pháp Kiểm tra kiểu, ta đã có sẵn thông tin về bộ biến ngay từ đầu và chỉ cần kiểm tra xem người lập trình có tuân thủ đúng quy tắc không trước khi sinh ra mã ở ngôn ngữ cấp cao. Giải pháp này yêu cầu can thiệp vào trình dịch ngược ít và hiện thực dễ dàng. Tuy nhiên, giải pháp còn nhiều hạn chế như phương pháp phân tích dữ liệu chưa đạt độ chính xác cao, cần người dùng phải chỉnh sửa lại chú thích theo mẫu quy định... Chính vì vậy, giai đoạn sau của luận văn đã phát triển một hướng tiếp cận mới có độ chính xác cao hơn và không cần chỉnh sửa mã đầu vào của người dùng, đó là giải pháp Suy luận kiểu. Giải pháp này sẽ được trình bày ở chương tiếp theo.



